Hadoop
HDFS间数据传输
dsitcp：用于两个版本相同的HDFS间的数据传输，底层是通过MR的方式进行数据传输，不过只有MAP没有REDUCE。
HFTP：用于两个不同版本的HDFS间数据传输。

计算机网络
Tcp与 Udp


UDP（UserDatagramProtocol）是一个简单的面向消息的传输层协议，尽管UDP提供标头和有效负载的完整性验证（通过校验和），没有握手对话，UDP称为不可靠的数据报协议。
UDP 协议最大的特点就是速度快。
数据链路层 最大传输单元是 1500 字节 (MTU) ，要想 IP 层不分包，那么 UDP 数据包的最大大小应该是1500字节 – IP头(20字节) – UDP头(8字节) = 1472字节。
UDP在网络传输中，如果数据过大就会在IP层分片，每个片会包在 IP 协议中，存在以首部报文：
16 位标识：用来标识哪些包是同一个包拆分出来的；
3 位标志：通过这个片偏移来区分拆出来的包的顺序。即谁在前谁在后；
13 位片偏移：识别当前拆出来的包是否是最后一个包，如果标志位为 0，则标志着到达最后一个分片。类似于链表用 null 来表示结束标志。
java相关
1. 多线程
 Java自带哪几种线程池
1）newCachedThreadPool
创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是：如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为1分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。
在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。
2）newFixedThreadPool
创建一个定长的线程池，超出部分列入池队列中，缺点是：空闲线程不会释放。
3）newSingleThreadExecutor
创建一个线程来按照制定顺序运行任务，如果线程挂掉就会有新的补上。优点：顺序执行；缺点：单一、慢
4）newScheduleThreadPool
创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。延迟3秒执行
线程类
1）extend thread start方法
2）runable 封装 thread 方法  启动线程需要 runable对象放入thread（runable）.start 启动
3)	callable 同上 区别：有返回值
注意：继承 runable和callable需要重写 run方法，但是run方法不能启动线程，需要start方法。
线程独立性
线程与mian方法相互独立，mian线程结束，启动的线程不会一起结束，而是独立完成。
Threadlocal
       一个线程要存数据，可以调用自己的Threadlocalmap的k-v来存储，v可以放要存储的对象，那么怎么保证key值的唯一呢，可以创建一个ThreadLocal对象，ThreadLocal对象调用set（v）方法，TL的set方法会获取当前线程及其TLmap，如何将ThreadLocal自己的对象为key放入，该线程的map中，每一个TL都是唯一的，这样就保证了key值的唯一性。如果要存储多个数据需要多个TL，因为重复放会覆盖。
   当TL对象不使用后，可以把TL的引用为null，线程的map中引用TL对象为软引用，因此cg会回收TL对象从而防止内存泄漏。但是map中v引用的对象为强引用不会被cg，这就导致v的对象造成内存泄漏。所以在回收TL对象使可以使用tl.remove()方法，可以去除map中对k-v的引用。从而cg k和v对象。
2. 写一个单例代码
不能创建实例，只能调用类方法返回已经定义好的实例；
饿汉式：已经创建好对象；
懒汉式：调用方法才创建对象
3. LinkedBlockingQueue原理
队列的读写分离（因为有锁），阻塞队列：队列满时不能写入先阻塞，为空时不能删除，也阻塞。
4.模板设计模式
制定好任务的流程，根据流程一步一步的完成，这种设计模式教模板设计模式。
5.HashMap底层源码，数据结构
hashMap的底层结构在jdk1.7中由数组+链表实现，在jdk1.8中由数组+链表+红黑树实现，以数组+链表的结构为例。

存放位置的计算：把key进行hash值计算，放到对应数组，如果指定数组已经有数据，看key值是否相同，相同则替换。不同着插入链表。jdk1.8后链表张迪
jdk1.8put数据的流程：

解读：如果数组容量不够，数组扩容为原来的2倍，并重新计算所有数据的位置key的hash/array。length。数组初始长度为16或2的倍数，如果不是则纠正为2的倍数。

jdk1.8以后PUT的方法

解读：扩容机制多了一个loadfactor扩容因子，array的长度到了就会扩容两倍。 链表长度大于就形成红黑树。

hashmap扩容优化
hashmap在jdk1.7前，扩容时会重新计算每个key的值然后重新放位置。1.8后，在扩容2的倍数时，只需移位hash值就可以轻松找到扩容后的位置。
移位前，为 0000001110   1111 hash值取后4位
扩容移位后，为 000000111  01111 hash值取后5位 
移位前后大小不变则，扩容后位置不变
如果移位bit为1则新的hash值为 原来的位置+原来的数组长度
6.JVM

JVM内存分哪几个区，每个区的作用是什么?
1) 方法区：
a. 有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载
b. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
c. 该区域是被线程共享的。
2) 虚拟机栈: 
a. 虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。
b. 虚拟机栈是线程私有的，它的生命周期与线程相同。
c. 局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用
d. 操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式
3) 本地方法栈：
本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。
4) 堆：
java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。
5) 程序计数器：
内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。（OOM ：out of memory）
8. synchronized的原理，缺点是什么，如何解决
作用：为了避免临界区静态条件的发生。采用互斥的方法让一个线程拥有对象锁。
monitor

使用synchronized的线程会关联monitor，monitor中会有3部分组成：
1.Waaitset：获取过锁，但是没有运行条件的线程；
2.Entylist：使用Synchronized的线程获取不到锁会进入entylist队列中等待释放。
3.Owner：目前锁的使用者，只能有一个。
CAS

有四种锁：
锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。在 JDK 1.6 中默认是开启偏向锁和轻量级锁的
1.偏向锁
偏向锁
偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
轻量级
轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
重量级锁
重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。
2.轻量级锁 
自旋锁的目标是降低线程切换的成本。如果锁竞争激烈，我们不得不依赖于重量级锁，让竞争失败的线程阻塞；如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。
顾名思义，轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。
Mark Word是对象头的一部分；每个线程都拥有自己的线程栈（虚拟机栈），记录线程和函数调用的基本信息。二者属于JVM的基础内容，此处不做介绍。
当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，自旋失败后再膨胀为重量级锁。
缺点
同自旋锁相似：
● 如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。

3.自旋锁 
首先，内核态与用户态的切换上不容易优化。但通过自旋锁，可以减少线程阻塞造成的线程切换（包括挂起线程和恢复线程）。
如果锁的粒度小，那么锁的持有时间比较短（尽管具体的持有时间无法得知，但可以认为，通常有一部分锁能满足上述性质）。那么，对于竞争这些锁的而言，因为锁阻塞造成线程切换的时间与锁持有的时间相当，减少线程阻塞造成的线程切换，能得到较大的性能提升。具体如下：
● 当前线程竞争锁失败时，打算阻塞自己
● 不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会
● 在自旋的同时重新竞争锁
● 如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己
如果在自旋的时间内，锁就被旧owner释放了，那么当前线程就不需要阻塞自己（也不需要在未来锁释放时恢复），减少了一次线程切换。
“锁的持有时间比较短”这一条件可以放宽。实际上，只要锁竞争的时间比较短（比如线程1快释放锁的时候，线程2才会来竞争锁），就能够提高自旋获得锁的概率。这通常发生在锁持有时间长，但竞争不激烈的场景中。
缺点
● 单核处理器上，不存在实际的并行，当前线程不阻塞自己的话，旧owner就不能执行，锁永远不会释放，此时不管自旋多久都是浪费；进而，如果线程多而处理器少，自旋也会造成不少无谓的浪费。
● 自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失，减少锁的使用是更好的选择。
● 如果锁竞争的时间比较长，那么自旋通常不能获得锁，白白浪费了自旋占用的CPU时间。这通常发生在锁持有时间长，且竞争激烈的场景中，此时应主动禁用自旋锁。
4.自适应自旋锁
自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：
● 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。
● 相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。
自适应自旋解决的是“锁竞争时间不确定”的问题。JVM很难感知到确切的锁竞争时间，而交给用户分析就违反了JVM的设计初衷。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定，因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。
缺点
然而，自适应自旋也没能彻底解决该问题，如果默认的自旋次数设置不合理（过高或过低），那么自适应的过程将很难收敛到合适的值。
5.重量级锁（设计从用户态到系统态，效率慢）
内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。
9.volatile使用场景和原理 ，与synchronized的区别
使共享变量具有可视性，每个线程都可以读取到最新的改动
10. HashMap和HashTable区别
1) 线程安全性不同
HashMap是线程不安全的，HashTable是线程安全的，其中的方法是Synchronize的，在多线程并发的情况下，可以直接使用HashTabl，但是使用HashMap时必须自己增加同步处理。
2) 是否提供contains方法
HashMap只有containsValue和containsKey方法；HashTable有contains、containsKey和containsValue三个方法，其中contains和containsValue方法功能相同。
3) key和value是否允许null值
Hashtable中，key和value都不允许出现null值。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。
4) 数组初始化和扩容机制
HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。
Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。
11 TreeSet和HashSet区别
HashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。
TreeSet是采用树结构实现（红黑树算法）。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法。它还提供了一些方法来处理排序的set，如first()，last()，headSet()，tailSet()等等。
12.红黑树
 作用：防止一条过长的单链数据，使效率变低。能够平衡数据，基于二叉查找树。
特征
红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。
性质1. 节点是红色或黑色。
性质2. 根节点是黑色。
性质3. 所有叶子都是黑色。（叶子是NUIL节点）
性质4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）
性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

其他细节：https://zhuanlan.zhihu.com/p/269576465

9.5 String buffer和String build区别
1、StringBuffer与StringBuilder中的方法和功能完全是等价的。
2、只是StringBuffer中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而StringBuilder没有这个修饰，可以被认为是线程不安全的。 
3、在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低
13.引用
软引用：
a=new  softreferece<>(new byte[1024]) ; 
a到softreferece是强引用，进行cg时不会被回收，而对象softreferece对byte对象是软引用，进行cg时如果内存不够那么byte就会被回收。强引用对象生成时，内存空间不足也会回收软引用。
弱引用：
a=new weekreferece<>(new byte[1024]);
a到weekrefererce是强引用，weekrefererce到byte是弱引用，弱引用在进行cg时会被回收，不管内存情况如何
hashmap的线程安全
1.通过colloectionSynchronizedmap（）方法返回一个被Synchronized（）包裹的代码块，返回的是一个全新的map而不是原来的。
这样简单明了的保证了hashmap的线程安全；缺点是因为是整个代码块被包裹所以发生线程冲突的概率也大。
2.通过重新改写hashmap，使用了新的锁机制（nonfairSync），把代码一段一段的加上锁，调用CAS方法保证线程的原子性与互斥性。优点是减少了线程冲突，缺点是代码繁琐
对象分配
逃逸分析决定对象能否留在栈内存中

Spark
数仓
SQL
where语句
执行顺序： 
（）》and》or》beetun
from where group by 聚合函数 having select order by limt 
执行过程
 先对每列数据进行where筛选，符合的才返回。
like用法
‘%a’，以a结尾
‘a%’，以a开头
‘%a%’，含a即可
‘_’,任意一个字符
beetwn 和 in
都是范围查询，in效率更高
limit
limit 1会先进行筛选，再向server层发送数据，
索引
索引下推
 非主键索引在查数据使会先查出对应的主键值然后再在主键索引查数据最后回表。索引下推就是设置联合索引，在联合索引中筛选掉一些数据，这样能够减少回表的次数。
索引覆盖
覆盖索引：如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据
不指定索引
innodb必须有主键索引
InnoDB 被称为索引组织型的存储引擎。主键使用的 B-Tree 来存储数据，即表行。这意味着 InnoDB 必须使用主键。如果表没有主键，InnoDB 会向表中添加一个隐藏的自动递增的 6 字节计数器，并使用该隐藏计数器作为主键
server和引擎层交互
 客户端--》server层 sql语句 --》给引擎



sql执行优化
https://blog.csdn.net/weixin_43673156/article/details/124312896
sql执行过程
https://blog.csdn.net/weixin_43673156/article/details/124312896
回表
https://blog.csdn.net/weixin_43673156/article/details/124312896
SQL的log文件
https://blog.csdn.net/yfm081616/article/details/121598755
MySQL 的事务
ACID
原子性： undolog来保证，会保留提交事务前的数据，回撤事务会回到之前数据。
隔离性：MVCC
一致性：其他性质来保证
持久性：redolog，会保留事务提交信息，即使事务没有提交成功，只要写入日志，就可以再次写入。
MYSQL的复制
主：master
才：slave
master的操作会写到bin log中，主库启动 i/o threat去顺序读取bin log中的数据，然后写到slave中的relay log中，然后slave中会启动ThreatSql线程去重新执行主库的sql操作，从而完成复制。
UDF（user defined function）
自定义函数，可以用来处理即席查询，和一些简单重复的数据处理
新型数据库
分布式数据库
一般来说，数据分片有两种方式：水平分片（行）和垂直分片（列）
分片算法一般针对水平分片：
1.hash分片：根据key值，利用hash算法，将行数据分到不同区域，数据分布比较平均。利于：随机查询，不利于：范围查询。
2.范围分片：根据key值，将一定范围行分到一个区域。利于：范围查询，不利于：随机查询。
3.融合算法：范围+hash
TiDB是实现垂直和水平融合
分布式原理：一台机器存储数据，其他节点存储备份，实现高可用。
大文件处理：达到一定阈值，拆分为两个文件，分别进行备份。
融合算法：数据先以范围分区到TIKV中（水平分片），如何再通过mvcc复制数据到TIFLASH中，进行列式存储转换，实现，列和行同时在一种数据库中。会根据SQL选用最高效的途径。
